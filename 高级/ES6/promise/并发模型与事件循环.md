**由运行时环境扩展至此**

## 并发模型
JavaScript有一个基于事件循环的并发模型。事件循环负责执行代码
、收集和处理事件以及执行队列中的子任务。

## 运行时概念
____________________________________
stack |          Heap
      |         Object          Object
frame |     Object         Object     Object
frame |                   Object
frame |
frame |            Object
frame |       Object
____________________________________
message message message ... Queue
____________________________________

### 栈 stack
函数调用形成了一个由若干帧组成的栈；
执行顺序：先入后出
栈帧 (参数 局部变量) bar(foo x)
栈帧 (参数 局部变量) foo(y z return xxx)

### 堆 Heap
对象被分配在堆中，堆是一个用来表示一大块内存区域的计算机术语

### 队列 Queue
一个JavaScript运行时包含了一个待处理的消息队列。每一个消息都关联着一个用以处理这个消息的回调函数。
处理顺序:先入先出;
调用一个函数总是为其创建一个新的栈帧。
函数的处理会一直进行到执行栈再次为空位置；然后事件循环将会处理队列中的下一个消息。



## 事件循环
按如下方式进行
```bash
while(queue.waitForMessage()){
    queue.processNextMessage()
}
```
queue.waitForMessage 会同步的等待消息到达。

### 添加消息
1. 每当一个事件发生并且有一个事件监听绑定在该事件上，一个消息就会添加至消息队列。
2. settimeout(fn,time) time延迟后加入消息队列(0 时=> 最小为4ms)。

### 多个运行时互相通信

一个web worker或者一个跨域的iframe都有自己的栈、堆和消息队列。两个不同的运行时只能通过postMessage方法进行通信。如果另一个运行时侦听到message事件，则此方法会向该运行时添加消息

## 永不阻塞
javascript的事件循环模型与其他语言不同的一个有趣的特性时，它用不阻塞。
处理I/O通过事件和回调来执行，所以当一个应用正在等待一个数据查询时，它可以处理其他事情，比如用户输入。




## 内存管理

### 简介

像c语言这样的底层语言一般都有底层的内存管理接口，比如malloc和free()。
相反，js在创建变量时自动进行了分配内存，并且在不用他们时**自动**释放。释放的过程被称为垃圾回收。

### 内存生命周期

1. 分配所需要的内存
2. 使用分配到的内存（读写）
3. 不需要时释放


### javascript的内存分配

+ 值的初始化 分配内存
定义新变量，函数
+ 通过函数调用内配内存
```js
var d = new Date(); // 分配一个 Date 对象
var e = document.createElement("div"); // 分配一个 DOM 元素

var s = "azerty";
var s2 = s.substr(0, 3); // s2 是一个新的字符串
// 因为字符串是不变量，
// JavaScript 可能决定不分配内存，
// 只是存储了 [0-3] 的范围。

var a = ["ouais ouais", "nan nan"];
var a2 = ["generation", "nan nan"];
var a3 = a.concat(a2);
// 新数组有四个元素，是 a 连接 a2 的结果

```

 ### 使用值
 读写

 ### 不再需要时释放
 高级语言解释器潜入了垃圾回收器，主要工作时跟踪内存的分配和使用



 ## 垃圾回收
 垃圾回收算法主要依赖于**引用**的概念。
 在内存管理的环境中，一个对象如果有访问另一个对象的权限，叫做一个对象应用了另一个对象。例如：一个javascript对象具有对它原型的隐式引用和属性的显式引用。这里的对象还包括函数作用域。(全局词法作用域)

 ### 引用计数垃圾收集
最初的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”，如果没有，该对象将被垃圾回收机制回收。
**限制：循环引用**
该算法有个限制：无法处理循环引用的事例。他们不会被回收


### **标记-清除算法**

这个算法把“对象是否不在需要”简化定义为“**对象是否可以获得**”
垃圾回收期将定期从跟（window全局对象）开始，找所有从根开始引用的对象，然后赵这些对象引用的对象……从跟开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象。
+ 循环引用不再是问题了
在上面的示例中，函数调用返回之后，两个对象从全局对象出发无法获取。因此，他们将会被垃圾回收器回收
+ 限制：那些无法从根对象查询到的对象都将被清除

