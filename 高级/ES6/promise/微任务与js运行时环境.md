## 背景
+ js是一门单线程语言，当时是很好的选择
+ 随着多核系统的发展，必须找到方法摆脱单线程语言的限制。
+ 自从定时器加入web api后，浏览器提供的js环境就已经逐渐发展到包含任务调度、多线程应用开发等强大的特性。queueMicrotask

## js执行上下文
+ 当一段js代码运行时，它实际上在运行在**执行上下文**中,一下3中类型的代码会创建一个新的执行上下文
1. 全局上下文是为运行代码主体而创建的执行上下文，也就是说，它是为哪些存在于js函数之外的任何代码而创建的
2. 每个函数会在执行的时候创建自己的执行上下文
3. 通过eval函数也会创建一个新的执行上下文

每一个上下文本质上都是一种作用域层级，**每个代码段**执行的时候都会创建一个新的**上下文**来运行它，并且在代码退出的时候销毁。


关于递归函数（即多次调用自身的函数），需要特别注意：每次递归调用自身都会创建一个新的上下文。这使得 JavaScript 运行时能够追踪递归的层级以及从递归中得到的返回值，但这也意味着每次递归都会**消耗内**存来创建新的上下文。

## js运行时
在执行js代码的时候*，**js运行时**实际上维护了一组用于执行js代码的**代理**。
每个代理由一组**上下文的集合**、**执行上下文栈**、**主线程**、**一组可能用于执行worker的额外线程集合**、**一个任务队列**以及**一个微任务队列**构成。除了主线程之外（某些浏览器在多个代理之间共享的主线程），其他组成部分对于该代理都是唯一的

## 事件循环

每一个代理都是由事件循环(event loop)驱动的,**事件循环**负责**收集事件**、**对任务进行排队**以便在合适的时候执行回调。然后它**执行所有处于等待中的JavaScript任务**，然后是**执行微任务**，然后在开始下一次循环之前执行一些必要的**渲染和绘制**操作。

网页或者app的代码和浏览器本身的用户界面程序运行存在相同的**线程**中，共享相同的事件循环。该线程就是主线程，它除了运行网页本身的代码外，还负责收集和派发用户和其他事件，以及渲染和绘制网页内容等。

事件循环驱动着浏览器中发生的一切，因为他与用户的交互有关，但对于我们这里的目的来说，更重要的是它负责调度和执行其线程中运行的每一段代码。

### 由如下三种事件循环
1. window事件循环
window事件循环驱动所有共享同源的窗口
2. worker事件循环
worker事件循环驱动所有worker的事件循环，包括 web worker、shared worker和service worker。worker被保存在一个或多个主代码分开的代理中；浏览器可以对所有特定类型的工作者使用一个事件循环，也可以用多个事件循环来处理他们
3. worklet循环，包括worklet audiowoklet painetWorklet

**多个同源窗口可能运行在相同的事件循环中**，每个队列任务进行到事件循环中以便处理器能轮流对他们进行处理。这里的window实际上值“用于运行网页内容的浏览器容器”，包括实际的window、标签页或一个frame

在特定情况下，同源窗口之间共享事件循环。例如：
+ 一个窗口打开了另一个窗口，他们可能会共享一个事件循环
+ 窗口包含在iframe容器中
+ 在多进程浏览器中斗个窗口碰巧共享了一个进程


## 任务与微任务

一个任务就是指计划由标准机制来执行的任何JavaScript，如程序的初始化、事件触发的回调等。除了使用事件，还可以用settimeout,setinterval来添加任务。

区别：
+ 当执行来自任务队列中的任务时，在每一次事件循环开始迭代的时候运行时都会执行队列中的每个任务。**在每次迭代开始之后加入到队列中的任务需要在下一次迭代开始之后才会执行**  （例如settimeout要当当前任务执行完下一次迭代才执行）
+ **每次当一个任务退出且执行上下文栈为空的时候，微任务队列中的每一个微任务会依次被执行**。不同的是，他会等到微任务队列为空时，才停止执行——即使中途有微任务加入。话句话说，微任务可以添加新的微任务到队列中，这些**新的微任务将在下一个任务开始运行执行前，在当前事件循环迭代之前运行**。 

另一篇文章解释的关键区别：
+  首先当没有给任务存在，事件循环都会检查该任务是否正把控制权交给其他js代码。如果不然，事件循环就会运行微任务队列中的所有微任务。接下来微任务循环会在事件循环的每次迭代中被处理多次，包括处理完事件和其他回调
+ 其次，如果一个微任务通过调用queueMicrotask(),向队列中加入了更多的微任务，那些**新加入的微任务会早于下一个任务运行**。这是因为事件循环会持续调用微任务直至队列中没有留存的，即使是在有更多微任务被加入的情况下。


### 可能的问题
代码阻塞了或者进入了无限循环，则浏览器将会卡死。无论是由于 bug 引起还是代码中进行复杂的运算导致的性能降低，都会降低用户的体验。
## 解决方案
1. 使用 web worker 可以让主线程另起新的线程来运行脚本，这能够缓解上面的情况。一个设计良好的网站或应用会把一些复杂的或者耗时的操作交给 worker 去做，这样可以让主线程除了更新、布局和渲染网页之外，尽可能少的去做其他事情。

2. 通过使用像promise这样的异步js技术可以使得主线程在等待请求返回结果的同时继续往下执行，者能够进一步减轻代码阻塞情况。

3. 微任务是另一种解决方案，通过将代码安排在下一次事件循环开始之前而不是必须要等到下一次开始之后才执行，这样可以提供一个好的访问级别。
queueMicrotask()可以让开发者创建一个统一的微任务队列，在任何需要有能力安排代码在js执行上下文栈上没有执行上下文时安全运行的地方使用。



## 微任务详解
一个微任务就是一个简短的函数，当创建该微任务的函数执行之后，并且只有当js调用栈为空，而控制权尚未返还给**用户代理**用来驱动脚本执行环境的事件循环之前，该微任务才会被执行。事件循环可能时浏览器的主事件循环也可能时被一个web worker所驱动的事件循环。这使得给定的函数在没有其他脚本执行干扰的情况下运行，也保证了微任务能在用户代理有机会对微任务带来的行为做出反应之前运行。

JavaScript中的promise和mutation observer(监听dom变化)都是使用微任务队列来与与运行他们的回调函数，但当能够推迟工作直到当前事件循环过程完结时，也时可以执行微任务的时机。为了允许第三方库、控件、polyfill能使用微任务，window和worker接口上暴漏了queueMicrotask()方法。



## 任务
一个任务就是由执行诸如从头开始执行一段程序、执行一个事件回调、一个interval timeout 被触发之类的标准机制而被调度的任意js代码。这些都在任务队列（task queue）上被调度。

在一下时机，任务会被**添加**到**任务队列**
+ 一段新程序或子进程直接被执行时（比如从一个控制台或在一个script标签元素中运行代码）
+ 触发了一个事件，将其回调函数添加到任务队列时。
+ 执行到一个由settimout或setinterval创建的timeout或interval，以致响应的回调函数被添加到任务队列。

事件循环驱动你的代码按照这些任务队列的顺序，一个接一个的处理他们。在事件循环的单次迭代中，将执行任务队列中最旧的可以运行任务。之后，微任务将被执行，直到微任务队列为空，然后浏览器可以选择更新渲染，然后浏览器继续进行事件循环的下一次迭代。

### 例子
```js
let callback = () => log("Regular timeout callback has run");

let urgentCallback = () => log("*** Oh noes! An urgent callback has run!");

log("Main program started");
setTimeout(callback, 0);
queueMicrotask(urgentCallback);
log("Main program exiting");
// Main program started
// Main program exiting
// *** Oh noes! An urgent callback has run!
// Regular timeout callback has run

```

```js

let callback = () => log("Regular timeout callback has run");

let urgentCallback = () => log("*** Oh noes! An urgent callback has run!");

let doWork = () => {
  let result = 1;

  queueMicrotask(urgentCallback);

  for (let i = 2; i <= 10; i++) {
    result *= i;
  }
  return result;
};

log("Main program started");
setTimeout(callback, 0);
log(`10! equals ${doWork()}`);
log("Main program exiting");

//  dowork函数调用了queueMicrotask(),但微任务仍在程序退出时才触发，因为那才是任务退出而执行栈上为空的时刻。

// 此例的重要之处是微任务不在其所处的函数退出时，而是在主程序退出时被执行。
// Main program started
// 10! equals 3628800
// Main program exiting
// *** Oh noes! An urgent callback has run!
// Regular timeout callback has run

```